
Verilator is a nice verilog simulator.  Super easy to interface the
logic with C/C++.

Getting and installing verilator is described on their website:
http://www.veripool.org/wiki/verilator/Installing

Basically:

git clone http://git.veripool.org/git/verilator   # Only first time
cd verilator
git pull        # Make sure we're up-to-date
git tag         # See what versions exist
autoconf        # Create ./configure script
unsetenv VERILATOR_ROOT  # For csh; ignore error if on bash
unset VERILATOR_ROOT  # For bash
./configure
make  # this can take a while
make install



In the lsasim/verilator directory there is a Makefile, a copy of the
lsa rtl (lsa.cdl), vmail.cpp which is the C++ code that integrates the
rtl simulation with memory and peripherals (implemented in C++).

vmail.cpp uses a file named sram.h which lsa-as generates whenever it
assembles some code.  The compiled in program can be overriden on the
command line by specifiying a .s.csv file (also generated by lsa-sim)
when the verilator simulation is run.

Running make will build an rtl based simulation of the lsa processor
obj_dir/Vlsa.

The vmain.cpp version runs for 2000 clock cycles, to change that number
edit this line
    if(tick>2000) break;
This version also craetes a .vcd file named test.vcd, use gtkwave to
view this file.  Basically you dont want to run forever (with this
version) to avoid this file growing indefinitely.  Note that the
verilator simulation main program prints out
    show 0x1234
in the same way that lsa-sim does.

make -f Makefile.forever

will build a verilator simulation that runs in an infinite loop without
building a .vcd file.

lsa.cdl is the rtl source, a tool called cyclicity-cdl (see the readme
file) is used to turn that into verilog (lsa.v).  Lsa.v is included
in the repo so you dont have to have both cdl and verilator to try
out verilator.



